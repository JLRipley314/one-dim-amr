\documentclass[10pt,letter]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{fullpage}
\renewcommand{\arraystretch}{2}
\usepackage{braket}
\usepackage{hyperref}

\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}

\title{One dimensional adaptive mesh refinement}    
\author{Justin Ripley
	\\Princeton University}
\date{\today}
 
\maketitle 
     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
       Basic layout of the amr code. A lot of this comes from the AMRD/PAMR
library written by Frans Pretorius (with addtions by Branson Stevens).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organization of data}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic algorithms}

	With fixed mesh refinment we do not need the regridding routine,
which is perhaps the most complicated part of the algorithm. Note also
we do \emph{not} implement multiple grids at the same level.

\begin{algorithm}
\caption{Evolve}\label{alg:time_step}
\begin{algorithmic}[1]
\Procedure{Evolve}{grid,times}
	\For{$t\gets1,times$}
		\State{$grid.time\gets grid.time+1$}
		\If{$grid.time\mathrm{mod}(\texttt{regrid})=0$}
			\State\Call{Regrid}{$grid$}
		\EndIf 
		\If{$grid.interior=\texttt{true}$}
			\State{\Call{Interpolate\_Boundary\_Conditions}{$grid.parent,grid$}}	
		\EndIf
		\State{\Call{Solve\_PDE\_Step}{$grid$}}
		\If{$grid.child\neq\varnothing$}
			\State{\Call{Evolve}{$grid.child,\texttt{refinement}$}}
		\EndIf
	\EndFor
	\If{$grid.parent\neq\varnothing$}
		\State{\Call{Compute\_Truncation\_Error}{$grid.parent,grid$}}
		\State{\Call{Inject}{$grid.parent,grid$}}
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


\end{document}
